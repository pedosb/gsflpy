import sys

class ConsoleOptions(object):
   def __init__(self,
	 args,
	 usage = None):
      self.dict_of_args = {'-isl' : '-iscorrectlattice'}
      self.args = self.norm_args(args)
      self.read = len(args)*[False]
      self.user_usage = usage
      
   def norm_args(self, args):
      new_args = []
      for arg in args:
	 try:
	    new_args.append(self.dict_of_args[arg])
	 except KeyError:
	    new_args.append(arg)
      return new_args

   def get_option(self, option):
      self.current_option = '-'+option
      option = self.norm_args(['-'+option])[0][1:]
      try:
	 option_index = self.args.index('-'+option)
      except ValueError:
	 if option == 'L':
	    return None, None, None
	 if option == 'm':
	    return None, None
	 if option in ['l', 'w', 'c', 'o', 'F', 'A', 'f', 'g']:
	    return None
	 if option == 'p':
	    return self.get_option('fp')
	 if option == 'fp':
	    return None
	 if option in ['iscorrectlattice', 'C']:
	    return False

      self.read[option_index] = True
      #Retrun a tuple with the lists:
      #lat_file_name, max_node, correct_sentence
      if option == 'L':
	 input_file_name = self.get_arg(option_index+1)
	 LAT_FILE = []
	 MAX_NODE = []
	 CORRECT_SENTENCE = []
	 for line in open(input_file_name):
	    try:
	       words = line.split()
	       LAT_FILE.append(words[0])
	       MAX_NODE.append(words[1])
	       sentence = ""
	       for word in words[2:len(words)]:
		  sentence += word + ' '
	       CORRECT_SENTENCE.append(sentence.strip())
	    except:
	       print 'ERROR: Cannot read lattice list file. Maybe syntax error.'
	       #TODO make it better
	       sys.exit(-1)
	 return LAT_FILE, MAX_NODE, CORRECT_SENTENCE
      #Retun a tuple of weka classifier and instances (generated by the model file to
      #compare test attributes)
      if option == 'm':
	 import java.io.FileInputStream as FileInputStream
	 import java.io.ObjectInputStream as ObjectInputStream

	 import weka.core.Instances as Instances

	 model_file_name = self.get_arg(option_index+1)
	 object_input_stream = ObjectInputStream(FileInputStream(model_file_name))
	 classifier = object_input_stream.readObject()
	 classifier_instances = Instances(object_input_stream.readObject())
	 object_input_stream.close()
	 return classifier, classifier_instances
      if option == 'l':
	 return self.get_arg(option_index+1)
      if option in ['w', 'g']:
	 number = self.get_arg(option_index+1)
	 try:
	    return int(number)
	 except ValueError:
	    self.usage('-'+str(option)+" argument must be an integer. Found: '" + 
		  str(number) + "'.")
      if option in ['c', 'o', 'F', 'A', 'f']:
	 return self.get_arg(option_index+1)
      if option in ['iscorrectlattice', 'C']:
	 return True
      if option == 'p':
	 confusion = (self.get_arg(option_index+1).split(','), self.get_arg(option_index+2).split(','))
	 if len(confusion[0]) != len(confusion[1]):
	    self.usage('-p Correct and recognized states must be the same lenght.')
	 return confusion
      if option == 'fp':
	 confusions = ([],[])
	 for line in open(self.get_arg(option_index+1)):
	    if line != '\n':
	       phones = line.split()
	       confusions[0].append(phones[0])
	       confusions[1].append(phones[1])
	 if len(confusions[0]) != 0:
	    if len(confusions[0]) != len(confusions[1]):
	       self.usage('ERROR: syntax on file'+str(self.get_arg(option_index+1)))
	 return confusions

   def get_arg(self, index):
      try:
	 arg = self.args[index]
	 if not arg.startswith('-'):
	    self.read[index] = True
	    return arg
      except IndexError:
	 pass
      self.usage(self.current_option + 
	    ' needs argument.')

   def check_all_read(self):
      message = 'Unknown option(s): '
      if False not in self.read[1:len(self.read)]:
	 return
      for index in range(1,len(self.read)):
	 if not self.read[index]:
	    message += "'" + str(self.args[index]) + "',"
      self.usage(message=message[0:len(message)-1])

   def print_error_options(self, error_options):
      if not error_options:
	 return
      if not isinstance(error_options, list):
	 error_options = [error_options]
      for error_option in error_options:
	 if error_option == 'l':
	    print 'ERROR: You must specify a lattice file.'
	 elif error_option == 'w':
	    print ('ERROR: You must specify the max number of' + 
		  'nodes to use in search.')
	 elif error_option == 'c':
	    print ('ERROR: You must specify the correct sentence.')
	 else:
	    print 'WARNING error_option not found.'

   def usage(self,
	 message = None,
	 error_options = None):
      self.print_error_options(error_options)
      print message,'\n'
      print 'Usage:'
      if self.user_usage:
	 self.user_usage()
      gsflpy = self.args[0].endswith('Main.py')
      if self.args[0].endswith('GsflReScore.py') or gsflpy:
	 print ('  -L: File that contains the path for lattice file (whithout spaces)' +
	       'followed by the number of max words and then correct transcription (one per line).')
      if gsflpy:
	 print '  -l: File that contains the lattice.'
	 print '  -w: Max number of nodes per sentence.'
	 print '  -c: Correct sentence.'
	 print '  -o: Name of a file to store the figure (png).'
	 print '  -A: File to write the ARFF.'
	 print '  -F: File to write the confusion regions.'
	 print '  -f: File to read the confusion regions.'
	 print ('  -iscorrectlattice (-isl): Allow gsflpy use confusion region of ' +
	       'correct recognized files and/or set it to search for negative margins.')
	 print '  -C: Set confusion as yes.'
	 print '  -p: HMM models to considerer confusion. <recognized1>,<recognized2>,... <correct1>,<correct2>,...'
	 sys.exit(-1)
